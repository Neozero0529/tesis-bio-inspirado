// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages_DRSServer.proto

#ifndef PROTOBUF_messages_5fDRSServer_2eproto__INCLUDED
#define PROTOBUF_messages_5fDRSServer_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_messages_5fDRSServer_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsMVector2Impl();
void InitDefaultsMVector2();
void InitDefaultsMObstacleImpl();
void InitDefaultsMObstacle();
void InitDefaultsMRequestStatusImpl();
void InitDefaultsMRequestStatus();
void InitDefaultsMRobotStatusImpl();
void InitDefaultsMRobotStatus();
void InitDefaultsMCommandImpl();
void InitDefaultsMCommand();
void InitDefaultsMDRSServerImpl();
void InitDefaultsMDRSServer();
inline void InitDefaults() {
  InitDefaultsMVector2();
  InitDefaultsMObstacle();
  InitDefaultsMRequestStatus();
  InitDefaultsMRobotStatus();
  InitDefaultsMCommand();
  InitDefaultsMDRSServer();
}
}  // namespace protobuf_messages_5fDRSServer_2eproto
class MCommand;
class MCommandDefaultTypeInternal;
extern MCommandDefaultTypeInternal _MCommand_default_instance_;
class MDRSServer;
class MDRSServerDefaultTypeInternal;
extern MDRSServerDefaultTypeInternal _MDRSServer_default_instance_;
class MObstacle;
class MObstacleDefaultTypeInternal;
extern MObstacleDefaultTypeInternal _MObstacle_default_instance_;
class MRequestStatus;
class MRequestStatusDefaultTypeInternal;
extern MRequestStatusDefaultTypeInternal _MRequestStatus_default_instance_;
class MRobotStatus;
class MRobotStatusDefaultTypeInternal;
extern MRobotStatusDefaultTypeInternal _MRobotStatus_default_instance_;
class MVector2;
class MVector2DefaultTypeInternal;
extern MVector2DefaultTypeInternal _MVector2_default_instance_;

// ===================================================================

class MVector2 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MVector2) */ {
 public:
  MVector2();
  virtual ~MVector2();

  MVector2(const MVector2& from);

  inline MVector2& operator=(const MVector2& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MVector2(MVector2&& from) noexcept
    : MVector2() {
    *this = ::std::move(from);
  }

  inline MVector2& operator=(MVector2&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MVector2& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MVector2* internal_default_instance() {
    return reinterpret_cast<const MVector2*>(
               &_MVector2_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(MVector2* other);
  friend void swap(MVector2& a, MVector2& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MVector2* New() const PROTOBUF_FINAL { return New(NULL); }

  MVector2* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MVector2& from);
  void MergeFrom(const MVector2& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MVector2* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // required double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // @@protoc_insertion_point(class_scope:MVector2)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double x_;
  double y_;
  friend struct ::protobuf_messages_5fDRSServer_2eproto::TableStruct;
  friend void ::protobuf_messages_5fDRSServer_2eproto::InitDefaultsMVector2Impl();
};
// -------------------------------------------------------------------

class MObstacle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MObstacle) */ {
 public:
  MObstacle();
  virtual ~MObstacle();

  MObstacle(const MObstacle& from);

  inline MObstacle& operator=(const MObstacle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MObstacle(MObstacle&& from) noexcept
    : MObstacle() {
    *this = ::std::move(from);
  }

  inline MObstacle& operator=(MObstacle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MObstacle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MObstacle* internal_default_instance() {
    return reinterpret_cast<const MObstacle*>(
               &_MObstacle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(MObstacle* other);
  friend void swap(MObstacle& a, MObstacle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MObstacle* New() const PROTOBUF_FINAL { return New(NULL); }

  MObstacle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MObstacle& from);
  void MergeFrom(const MObstacle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MObstacle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .MVector2 pos = 2;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 2;
  const ::MVector2& pos() const;
  ::MVector2* mutable_pos();
  ::MVector2* release_pos();
  void set_allocated_pos(::MVector2* pos);

  // required int32 obstacleId = 1;
  bool has_obstacleid() const;
  void clear_obstacleid();
  static const int kObstacleIdFieldNumber = 1;
  ::google::protobuf::int32 obstacleid() const;
  void set_obstacleid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MObstacle)
 private:
  void set_has_obstacleid();
  void clear_has_obstacleid();
  void set_has_pos();
  void clear_has_pos();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::MVector2* pos_;
  ::google::protobuf::int32 obstacleid_;
  friend struct ::protobuf_messages_5fDRSServer_2eproto::TableStruct;
  friend void ::protobuf_messages_5fDRSServer_2eproto::InitDefaultsMObstacleImpl();
};
// -------------------------------------------------------------------

class MRequestStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MRequestStatus) */ {
 public:
  MRequestStatus();
  virtual ~MRequestStatus();

  MRequestStatus(const MRequestStatus& from);

  inline MRequestStatus& operator=(const MRequestStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MRequestStatus(MRequestStatus&& from) noexcept
    : MRequestStatus() {
    *this = ::std::move(from);
  }

  inline MRequestStatus& operator=(MRequestStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MRequestStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MRequestStatus* internal_default_instance() {
    return reinterpret_cast<const MRequestStatus*>(
               &_MRequestStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(MRequestStatus* other);
  friend void swap(MRequestStatus& a, MRequestStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MRequestStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  MRequestStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MRequestStatus& from);
  void MergeFrom(const MRequestStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MRequestStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 robotId = 1;
  bool has_robotid() const;
  void clear_robotid();
  static const int kRobotIdFieldNumber = 1;
  ::google::protobuf::int32 robotid() const;
  void set_robotid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MRequestStatus)
 private:
  void set_has_robotid();
  void clear_has_robotid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 robotid_;
  friend struct ::protobuf_messages_5fDRSServer_2eproto::TableStruct;
  friend void ::protobuf_messages_5fDRSServer_2eproto::InitDefaultsMRequestStatusImpl();
};
// -------------------------------------------------------------------

class MRobotStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MRobotStatus) */ {
 public:
  MRobotStatus();
  virtual ~MRobotStatus();

  MRobotStatus(const MRobotStatus& from);

  inline MRobotStatus& operator=(const MRobotStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MRobotStatus(MRobotStatus&& from) noexcept
    : MRobotStatus() {
    *this = ::std::move(from);
  }

  inline MRobotStatus& operator=(MRobotStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MRobotStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MRobotStatus* internal_default_instance() {
    return reinterpret_cast<const MRobotStatus*>(
               &_MRobotStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(MRobotStatus* other);
  friend void swap(MRobotStatus& a, MRobotStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MRobotStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  MRobotStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MRobotStatus& from);
  void MergeFrom(const MRobotStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MRobotStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MObstacle obstacles = 3;
  int obstacles_size() const;
  void clear_obstacles();
  static const int kObstaclesFieldNumber = 3;
  const ::MObstacle& obstacles(int index) const;
  ::MObstacle* mutable_obstacles(int index);
  ::MObstacle* add_obstacles();
  ::google::protobuf::RepeatedPtrField< ::MObstacle >*
      mutable_obstacles();
  const ::google::protobuf::RepeatedPtrField< ::MObstacle >&
      obstacles() const;

  // optional .MVector2 pos = 2;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 2;
  const ::MVector2& pos() const;
  ::MVector2* mutable_pos();
  ::MVector2* release_pos();
  void set_allocated_pos(::MVector2* pos);

  // required int32 robotId = 1;
  bool has_robotid() const;
  void clear_robotid();
  static const int kRobotIdFieldNumber = 1;
  ::google::protobuf::int32 robotid() const;
  void set_robotid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MRobotStatus)
 private:
  void set_has_robotid();
  void clear_has_robotid();
  void set_has_pos();
  void clear_has_pos();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MObstacle > obstacles_;
  ::MVector2* pos_;
  ::google::protobuf::int32 robotid_;
  friend struct ::protobuf_messages_5fDRSServer_2eproto::TableStruct;
  friend void ::protobuf_messages_5fDRSServer_2eproto::InitDefaultsMRobotStatusImpl();
};
// -------------------------------------------------------------------

class MCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MCommand) */ {
 public:
  MCommand();
  virtual ~MCommand();

  MCommand(const MCommand& from);

  inline MCommand& operator=(const MCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MCommand(MCommand&& from) noexcept
    : MCommand() {
    *this = ::std::move(from);
  }

  inline MCommand& operator=(MCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MCommand* internal_default_instance() {
    return reinterpret_cast<const MCommand*>(
               &_MCommand_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(MCommand* other);
  friend void swap(MCommand& a, MCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MCommand* New() const PROTOBUF_FINAL { return New(NULL); }

  MCommand* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MCommand& from);
  void MergeFrom(const MCommand& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double vx = 2;
  bool has_vx() const;
  void clear_vx();
  static const int kVxFieldNumber = 2;
  double vx() const;
  void set_vx(double value);

  // required double vy = 3;
  bool has_vy() const;
  void clear_vy();
  static const int kVyFieldNumber = 3;
  double vy() const;
  void set_vy(double value);

  // required double t = 4;
  bool has_t() const;
  void clear_t();
  static const int kTFieldNumber = 4;
  double t() const;
  void set_t(double value);

  // required int32 robotId = 1;
  bool has_robotid() const;
  void clear_robotid();
  static const int kRobotIdFieldNumber = 1;
  ::google::protobuf::int32 robotid() const;
  void set_robotid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MCommand)
 private:
  void set_has_robotid();
  void clear_has_robotid();
  void set_has_vx();
  void clear_has_vx();
  void set_has_vy();
  void clear_has_vy();
  void set_has_t();
  void clear_has_t();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double vx_;
  double vy_;
  double t_;
  ::google::protobuf::int32 robotid_;
  friend struct ::protobuf_messages_5fDRSServer_2eproto::TableStruct;
  friend void ::protobuf_messages_5fDRSServer_2eproto::InitDefaultsMCommandImpl();
};
// -------------------------------------------------------------------

class MDRSServer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MDRSServer) */ {
 public:
  MDRSServer();
  virtual ~MDRSServer();

  MDRSServer(const MDRSServer& from);

  inline MDRSServer& operator=(const MDRSServer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MDRSServer(MDRSServer&& from) noexcept
    : MDRSServer() {
    *this = ::std::move(from);
  }

  inline MDRSServer& operator=(MDRSServer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MDRSServer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MDRSServer* internal_default_instance() {
    return reinterpret_cast<const MDRSServer*>(
               &_MDRSServer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(MDRSServer* other);
  friend void swap(MDRSServer& a, MDRSServer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MDRSServer* New() const PROTOBUF_FINAL { return New(NULL); }

  MDRSServer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MDRSServer& from);
  void MergeFrom(const MDRSServer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MDRSServer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .MRequestStatus request = 1;
  bool has_request() const;
  void clear_request();
  static const int kRequestFieldNumber = 1;
  const ::MRequestStatus& request() const;
  ::MRequestStatus* mutable_request();
  ::MRequestStatus* release_request();
  void set_allocated_request(::MRequestStatus* request);

  // optional .MCommand command = 2;
  bool has_command() const;
  void clear_command();
  static const int kCommandFieldNumber = 2;
  const ::MCommand& command() const;
  ::MCommand* mutable_command();
  ::MCommand* release_command();
  void set_allocated_command(::MCommand* command);

  // @@protoc_insertion_point(class_scope:MDRSServer)
 private:
  void set_has_request();
  void clear_has_request();
  void set_has_command();
  void clear_has_command();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::MRequestStatus* request_;
  ::MCommand* command_;
  friend struct ::protobuf_messages_5fDRSServer_2eproto::TableStruct;
  friend void ::protobuf_messages_5fDRSServer_2eproto::InitDefaultsMDRSServerImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MVector2

// required double x = 1;
inline bool MVector2::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MVector2::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MVector2::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MVector2::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double MVector2::x() const {
  // @@protoc_insertion_point(field_get:MVector2.x)
  return x_;
}
inline void MVector2::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:MVector2.x)
}

// required double y = 2;
inline bool MVector2::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MVector2::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MVector2::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MVector2::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double MVector2::y() const {
  // @@protoc_insertion_point(field_get:MVector2.y)
  return y_;
}
inline void MVector2::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:MVector2.y)
}

// -------------------------------------------------------------------

// MObstacle

// required int32 obstacleId = 1;
inline bool MObstacle::has_obstacleid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MObstacle::set_has_obstacleid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MObstacle::clear_has_obstacleid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MObstacle::clear_obstacleid() {
  obstacleid_ = 0;
  clear_has_obstacleid();
}
inline ::google::protobuf::int32 MObstacle::obstacleid() const {
  // @@protoc_insertion_point(field_get:MObstacle.obstacleId)
  return obstacleid_;
}
inline void MObstacle::set_obstacleid(::google::protobuf::int32 value) {
  set_has_obstacleid();
  obstacleid_ = value;
  // @@protoc_insertion_point(field_set:MObstacle.obstacleId)
}

// required .MVector2 pos = 2;
inline bool MObstacle::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MObstacle::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MObstacle::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MObstacle::clear_pos() {
  if (pos_ != NULL) pos_->::MVector2::Clear();
  clear_has_pos();
}
inline const ::MVector2& MObstacle::pos() const {
  const ::MVector2* p = pos_;
  // @@protoc_insertion_point(field_get:MObstacle.pos)
  return p != NULL ? *p : *reinterpret_cast<const ::MVector2*>(
      &::_MVector2_default_instance_);
}
inline ::MVector2* MObstacle::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) {
    pos_ = new ::MVector2;
  }
  // @@protoc_insertion_point(field_mutable:MObstacle.pos)
  return pos_;
}
inline ::MVector2* MObstacle::release_pos() {
  // @@protoc_insertion_point(field_release:MObstacle.pos)
  clear_has_pos();
  ::MVector2* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void MObstacle::set_allocated_pos(::MVector2* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
  // @@protoc_insertion_point(field_set_allocated:MObstacle.pos)
}

// -------------------------------------------------------------------

// MRequestStatus

// required int32 robotId = 1;
inline bool MRequestStatus::has_robotid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MRequestStatus::set_has_robotid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MRequestStatus::clear_has_robotid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MRequestStatus::clear_robotid() {
  robotid_ = 0;
  clear_has_robotid();
}
inline ::google::protobuf::int32 MRequestStatus::robotid() const {
  // @@protoc_insertion_point(field_get:MRequestStatus.robotId)
  return robotid_;
}
inline void MRequestStatus::set_robotid(::google::protobuf::int32 value) {
  set_has_robotid();
  robotid_ = value;
  // @@protoc_insertion_point(field_set:MRequestStatus.robotId)
}

// -------------------------------------------------------------------

// MRobotStatus

// required int32 robotId = 1;
inline bool MRobotStatus::has_robotid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MRobotStatus::set_has_robotid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MRobotStatus::clear_has_robotid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MRobotStatus::clear_robotid() {
  robotid_ = 0;
  clear_has_robotid();
}
inline ::google::protobuf::int32 MRobotStatus::robotid() const {
  // @@protoc_insertion_point(field_get:MRobotStatus.robotId)
  return robotid_;
}
inline void MRobotStatus::set_robotid(::google::protobuf::int32 value) {
  set_has_robotid();
  robotid_ = value;
  // @@protoc_insertion_point(field_set:MRobotStatus.robotId)
}

// optional .MVector2 pos = 2;
inline bool MRobotStatus::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MRobotStatus::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MRobotStatus::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MRobotStatus::clear_pos() {
  if (pos_ != NULL) pos_->::MVector2::Clear();
  clear_has_pos();
}
inline const ::MVector2& MRobotStatus::pos() const {
  const ::MVector2* p = pos_;
  // @@protoc_insertion_point(field_get:MRobotStatus.pos)
  return p != NULL ? *p : *reinterpret_cast<const ::MVector2*>(
      &::_MVector2_default_instance_);
}
inline ::MVector2* MRobotStatus::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) {
    pos_ = new ::MVector2;
  }
  // @@protoc_insertion_point(field_mutable:MRobotStatus.pos)
  return pos_;
}
inline ::MVector2* MRobotStatus::release_pos() {
  // @@protoc_insertion_point(field_release:MRobotStatus.pos)
  clear_has_pos();
  ::MVector2* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void MRobotStatus::set_allocated_pos(::MVector2* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
  // @@protoc_insertion_point(field_set_allocated:MRobotStatus.pos)
}

// repeated .MObstacle obstacles = 3;
inline int MRobotStatus::obstacles_size() const {
  return obstacles_.size();
}
inline void MRobotStatus::clear_obstacles() {
  obstacles_.Clear();
}
inline const ::MObstacle& MRobotStatus::obstacles(int index) const {
  // @@protoc_insertion_point(field_get:MRobotStatus.obstacles)
  return obstacles_.Get(index);
}
inline ::MObstacle* MRobotStatus::mutable_obstacles(int index) {
  // @@protoc_insertion_point(field_mutable:MRobotStatus.obstacles)
  return obstacles_.Mutable(index);
}
inline ::MObstacle* MRobotStatus::add_obstacles() {
  // @@protoc_insertion_point(field_add:MRobotStatus.obstacles)
  return obstacles_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::MObstacle >*
MRobotStatus::mutable_obstacles() {
  // @@protoc_insertion_point(field_mutable_list:MRobotStatus.obstacles)
  return &obstacles_;
}
inline const ::google::protobuf::RepeatedPtrField< ::MObstacle >&
MRobotStatus::obstacles() const {
  // @@protoc_insertion_point(field_list:MRobotStatus.obstacles)
  return obstacles_;
}

// -------------------------------------------------------------------

// MCommand

// required int32 robotId = 1;
inline bool MCommand::has_robotid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MCommand::set_has_robotid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MCommand::clear_has_robotid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MCommand::clear_robotid() {
  robotid_ = 0;
  clear_has_robotid();
}
inline ::google::protobuf::int32 MCommand::robotid() const {
  // @@protoc_insertion_point(field_get:MCommand.robotId)
  return robotid_;
}
inline void MCommand::set_robotid(::google::protobuf::int32 value) {
  set_has_robotid();
  robotid_ = value;
  // @@protoc_insertion_point(field_set:MCommand.robotId)
}

// required double vx = 2;
inline bool MCommand::has_vx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MCommand::set_has_vx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MCommand::clear_has_vx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MCommand::clear_vx() {
  vx_ = 0;
  clear_has_vx();
}
inline double MCommand::vx() const {
  // @@protoc_insertion_point(field_get:MCommand.vx)
  return vx_;
}
inline void MCommand::set_vx(double value) {
  set_has_vx();
  vx_ = value;
  // @@protoc_insertion_point(field_set:MCommand.vx)
}

// required double vy = 3;
inline bool MCommand::has_vy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MCommand::set_has_vy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MCommand::clear_has_vy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MCommand::clear_vy() {
  vy_ = 0;
  clear_has_vy();
}
inline double MCommand::vy() const {
  // @@protoc_insertion_point(field_get:MCommand.vy)
  return vy_;
}
inline void MCommand::set_vy(double value) {
  set_has_vy();
  vy_ = value;
  // @@protoc_insertion_point(field_set:MCommand.vy)
}

// required double t = 4;
inline bool MCommand::has_t() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MCommand::set_has_t() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MCommand::clear_has_t() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MCommand::clear_t() {
  t_ = 0;
  clear_has_t();
}
inline double MCommand::t() const {
  // @@protoc_insertion_point(field_get:MCommand.t)
  return t_;
}
inline void MCommand::set_t(double value) {
  set_has_t();
  t_ = value;
  // @@protoc_insertion_point(field_set:MCommand.t)
}

// -------------------------------------------------------------------

// MDRSServer

// optional .MRequestStatus request = 1;
inline bool MDRSServer::has_request() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MDRSServer::set_has_request() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MDRSServer::clear_has_request() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MDRSServer::clear_request() {
  if (request_ != NULL) request_->::MRequestStatus::Clear();
  clear_has_request();
}
inline const ::MRequestStatus& MDRSServer::request() const {
  const ::MRequestStatus* p = request_;
  // @@protoc_insertion_point(field_get:MDRSServer.request)
  return p != NULL ? *p : *reinterpret_cast<const ::MRequestStatus*>(
      &::_MRequestStatus_default_instance_);
}
inline ::MRequestStatus* MDRSServer::mutable_request() {
  set_has_request();
  if (request_ == NULL) {
    request_ = new ::MRequestStatus;
  }
  // @@protoc_insertion_point(field_mutable:MDRSServer.request)
  return request_;
}
inline ::MRequestStatus* MDRSServer::release_request() {
  // @@protoc_insertion_point(field_release:MDRSServer.request)
  clear_has_request();
  ::MRequestStatus* temp = request_;
  request_ = NULL;
  return temp;
}
inline void MDRSServer::set_allocated_request(::MRequestStatus* request) {
  delete request_;
  request_ = request;
  if (request) {
    set_has_request();
  } else {
    clear_has_request();
  }
  // @@protoc_insertion_point(field_set_allocated:MDRSServer.request)
}

// optional .MCommand command = 2;
inline bool MDRSServer::has_command() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MDRSServer::set_has_command() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MDRSServer::clear_has_command() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MDRSServer::clear_command() {
  if (command_ != NULL) command_->::MCommand::Clear();
  clear_has_command();
}
inline const ::MCommand& MDRSServer::command() const {
  const ::MCommand* p = command_;
  // @@protoc_insertion_point(field_get:MDRSServer.command)
  return p != NULL ? *p : *reinterpret_cast<const ::MCommand*>(
      &::_MCommand_default_instance_);
}
inline ::MCommand* MDRSServer::mutable_command() {
  set_has_command();
  if (command_ == NULL) {
    command_ = new ::MCommand;
  }
  // @@protoc_insertion_point(field_mutable:MDRSServer.command)
  return command_;
}
inline ::MCommand* MDRSServer::release_command() {
  // @@protoc_insertion_point(field_release:MDRSServer.command)
  clear_has_command();
  ::MCommand* temp = command_;
  command_ = NULL;
  return temp;
}
inline void MDRSServer::set_allocated_command(::MCommand* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
  // @@protoc_insertion_point(field_set_allocated:MDRSServer.command)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_messages_5fDRSServer_2eproto__INCLUDED
